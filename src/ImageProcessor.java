import org.opencv.core.*;
import org.opencv.core.Point;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.nio.Buffer;

/**
 * Created by Jannik on 27.10.15.
 */

// Detects faces in an image, draws boxes around them, and writes the results
// to "faceDetection.png".
public class ImageProcessor {

    Converter convert = new Converter();
    ResourceLoader loadResource = new ResourceLoader();
    int counter = 0;

    public void detectFace(String URLString) {
        System.out.println("\nRunning DetectFace");

        // Create a face detector from the cascade file in the resources
        // directory.
        CascadeClassifier faceDetector = new CascadeClassifier(System.getProperty("user.dir") + "/src/resources/lbpcascade_frontalface.xml");
        BufferedImage buffImage = loadResource.imageFromURL(URLString);
        Mat image = convert.BufferedToMat(buffImage);

        // Detect faces in the image.
        // MatOfRect is a special container class for Rect.
        MatOfRect faceDetections = new MatOfRect();
        faceDetector.detectMultiScale(image, faceDetections);

        System.out.println(String.format("Detected %s faces", faceDetections.toArray().length));

        // Draw a bounding box around each face.
        for (Rect rect : faceDetections.toArray()) {
            Imgproc.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height), new Scalar(0, 255, 0));
        }

        saveMatAsPNG(image);
    }

    public void drawLettersOnGeneratedImage(String text, Color backgroundColor){

        for (int i = 0; i < text.length(); i++) {

            //Load image generated by ImageProcessor as BufferedImage
            BufferedImage originalImage = null;
            try {
                    originalImage = ImageIO.read(new File(System.getProperty("user.dir") + "/faceDetection_" + i + ".png"));
            } catch (IOException e) {
                e.printStackTrace();
            }

            System.out.print("Applying text on image ... ");
            BufferedImage textImage = new BufferedImage(
                    originalImage.getWidth(),
                    originalImage.getHeight(),
                    BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = textImage.createGraphics();
            FontRenderContext frc = g.getFontRenderContext();
            Font font = loadResource.customFont("Arial_Black.ttf", 240f); //(fontName, fontSize)
            Character c = text.charAt(i);
            GlyphVector gv = font.createGlyphVector(frc, c.toString());
            Rectangle2D box = gv.getVisualBounds();
            int xOff = textImage.getWidth()/2-100; //Vorher: int xOff = 25+(int)-box.getX();
            int yOff = textImage.getHeight()/2+75; //Vorher: int yOff = 80+(int)-box.getY();
            Shape shape = gv.getOutline(xOff, yOff);
            g.setClip(shape);
            g.drawImage(originalImage, 0, 0, null);
            g.setClip(null);
            g.setStroke(new BasicStroke(2f));
            g.setColor(Color.BLACK);
            g.setRenderingHint(
                    RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_ON);
            g.draw(shape);

            g.dispose();

            textImage = setBackgroundColor(textImage, backgroundColor);

            textImage = getCroppedImage(textImage);
            saveBuffImgAsPNG(textImage, i);

        }

        try {
            BufferedImage stitchedImages = stitchImages();
            saveBuffImgAsPNG(stitchedImages);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("Success!");
    }

    public BufferedImage getCroppedImage(BufferedImage source) {
        // Crops the parts of an image that have the same color as the top left pixel
        // The algorithm checks the image pixel by pixel. It stops when the current pixel does NOT equal the top left pixel
        // Therefore it draws a rectangle over the letter

        int baseColor = source.getRGB(0, 0);

        int width = source.getWidth();
        int height = source.getHeight();

        int topY = Integer.MAX_VALUE, topX = Integer.MAX_VALUE;
        int bottomY = -1, bottomX = -1;
        for(int y=0; y<height; y++) {
            for(int x=0; x<width; x++) {
                if (baseColor != source.getRGB(x, y)) {
                    if (x < topX) topX = x;
                    if (y < topY) topY = y;
                    if (x > bottomX) bottomX = x;
                    if (y > bottomY) bottomY = y;
                }
            }
        }

        BufferedImage destination = new BufferedImage( (bottomX-topX+1),
                (bottomY-topY+1), BufferedImage.TYPE_INT_ARGB);

        destination.getGraphics().drawImage(source, 0, 0,
                destination.getWidth(), destination.getHeight(),
                topX, topY, bottomX, bottomY, null);

        return destination;
    }


    public BufferedImage stitchImages() throws IOException {
        File dir = new File(System.getProperty("user.dir") + "/");
        File[] foundFiles = dir.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith("faceDetection_");
            }
        });

        int totalWidth = 0;
        BufferedImage resultImage = null;

        for (int i=1;i<foundFiles.length;i++){
            //BufferedImage buffImage = ImageIO.read(file);
            //totalWidth += buffImage.getWidth();

            BufferedImage firstImage = ImageIO.read(new File(System.getProperty("user.dir") + "/faceDetection_0.png"));
            BufferedImage secondImage = ImageIO.read(new File(System.getProperty("user.dir") + "/faceDetection_" + i + ".png"));

            resultImage = new BufferedImage(firstImage.getWidth() +
                    secondImage.getWidth(), firstImage.getHeight(),
                    BufferedImage.TYPE_INT_RGB);
            Graphics g = resultImage.getGraphics();
            g.drawImage(firstImage, 0, 0, null);
            g.drawImage(secondImage, firstImage.getWidth(), 0, null);
            saveBuffImgAsPNG(resultImage, 0);
        }
        return resultImage;

    }

    private BufferedImage setBackgroundColor(BufferedImage buffImage, Color backgroundColor) {
        BufferedImage newBuffImage = new BufferedImage(buffImage.getWidth(),buffImage.getHeight(),BufferedImage.TYPE_INT_ARGB);
        for (int x = 0; x < buffImage.getWidth(); x++){
            for (int y = 0; y < buffImage.getHeight(); y++){
                int rgba = buffImage.getRGB(x,y);
                boolean isTrans = (rgba & 0xff000000) == 0;
                if (isTrans){
                    newBuffImage.setRGB(x, y, (backgroundColor.getRGB()));
                } else {
                    newBuffImage.setRGB(x, y, rgba);
                }
            }
        }

        return newBuffImage;
    }

    private void saveMatAsPNG(Mat image) {
        String filename = "faceDetection_" + counter + ".png";
        counter++;
        System.out.println(String.format("Writing %s", filename));
        Imgcodecs.imwrite(filename, image);
        System.out.println("Image saved under " + System.getProperty("user.dir") + "/" + filename);
    }

    private void saveBuffImgAsPNG(BufferedImage buffImage, int counter) {
        try {
            ImageIO.write(buffImage, "png", new File(System.getProperty("user.dir") + "/faceDetection_" + counter + ".png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void saveBuffImgAsPNG(BufferedImage buffImage) {
        try {
            ImageIO.write(buffImage, "png", new File(System.getProperty("user.dir") + "/faceDetection.png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


}
